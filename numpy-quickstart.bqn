# NumPy quickstart
## Prerequisits
## The Basics

## An Example
# >>> a = np.arange(15).reshape(3, 5)
a ← ⟨3, 5⟩ ⥊ ↕15
a ← 3‿5 ⥊ ↕15
#┌─
#╵  0  1  2  3  4
#   5  6  7  8  9
#  10 11 12 13 14
#                 ┘
# >>> a
a
#┌─
#╵  0  1  2  3  4
#   5  6  7  8  9
#  10 11 12 13 14
#                 ┘
# >>> a.shape
≢a
#⟨ 3 5 ⟩
# >>> a.ndim
=a
#2
# >>> a.dtype.name
# BQN number type determined by implementation
# >>> a.itemsize
# >>> a.size
×´≢a
#15
# >>> type(a)
# >>> b = np.array([6, 7, 8])
b ← ⟨6, 7, 8⟩
b ← 6‿7‿8
# >>> b
b
#⟨ 6 7 8 ⟩
≢b
#⟨ 3 ⟩
=b
#1

## Array Creation
#>>> import numpy as np
#>>> a = np.array([2, 3, 4])
a ← ⟨2, 3, 4⟩
#>>> a
#array([2, 3, 4])
a
⟨2, 3, 4⟩
#>>> a.dtype
#dtype('int64')
#>>> b = np.array([1.2, 3.5, 5.1])
a ← ⟨1.2, 3.5, 5.1⟩
#>>> b.dtype
#dtype('float64')

#>>> b = np.array([(1.5, 2, 3), (4, 5, 6)])
b ← >⟨⟨1.5, 2, 3⟩, ⟨4, 5, 6⟩⟩
b ← >⟨1.5‿2‿3, 4‿5‿6⟩
b ← 2‿3 ⥊ 1.5‿2‿3‿4‿5‿6
#┌─
#╵ 1.5 2 3
#    4 5 6
#          ┘
#>>> b
#array([[1.5, 2. , 3. ],
#       [4. , 5. , 6. ]])
b
#┌─
#╵ 1.5 2 3
#    4 5 6
#          ┘

#>>> c = np.array([[1, 2], [3, 4]], dtype=complex)
#>>> c
#array([[1.+0.j, 2.+0.j],
#       [3.+0.j, 4.+0.j]])
# BQN no complex type yet

#>>> np.zeros((3, 4))
#array([[0., 0., 0., 0.],
#       [0., 0., 0., 0.],
#       [0., 0., 0., 0.]])
3‿4 ⥊ 0
#┌─
#╵ 0 0 0 0
#  0 0 0 0
#  0 0 0 0
#          ┘
#>>> np.ones((2, 3, 4), dtype=np.int16)
#array([[[1, 1, 1, 1],
#        [1, 1, 1, 1],
#        [1, 1, 1, 1]],
#
#       [[1, 1, 1, 1],
#        [1, 1, 1, 1],
#        [1, 1, 1, 1]]], dtype=int16)
2‿3‿4 ⥊ 1
#┌─
#╎ 1 1 1 1
#  1 1 1 1
#  1 1 1 1
#
#  1 1 1 1
#  1 1 1 1
#  1 1 1 1
#          ┘
#>>> np.empty((2, 3))
#array([[3.73603959e-262, 6.02658058e-154, 6.55490914e-260],  # may vary
#       [5.30498948e-313, 3.14673309e-307, 1.00000000e+000]])
# BQN no such thing as an uninitialized array?

#>>> np.arange(10, 30, 5)
#array([10, 15, 20, 25])
10+5×↕4
#⟨ 10 15 20 25 ⟩
5 {(⊑𝕩)+𝕨×↕⌈(-´⌽𝕩)÷𝕨} 10‿30  # dzaima, BQN message board, does not work for default w value
#⟨ 10 15 20 25 ⟩
ARange ← {(⊑𝕩)+𝕨×↕⌈(-´⌽𝕩)÷𝕨}
5 ARange 10‿30
#⟨ 10 15 20 25 ⟩
# a + c×↕⌊c÷˜b - a  dutchie, BQN message board: packing params in list poor BQN, just write as needed, like
10 + 5×↕⌊5÷˜30 - 10
# c×↕⌊b÷c  if a is 0, just this
# a+c×↕l  if length is known, this (see first BQN ex for this problem)
#>>> np.arange(0, 2, 0.3)  # it accepts float arguments
#array([0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8])
(1.8÷6)×↕7
#⟨ 0 0.3 0.6 0.8999999999999999 1.2 1.5 1.8 ⟩
0.3 ARange 0‿2
#⟨ 0 0.3 0.6 0.8999999999999999 1.2 1.5 1.8 ⟩

#>>> np.linspace(0, 2, 9)                   # 9 numbers from 0 to 2
#array([0.  , 0.25, 0.5 , 0.75, 1.  , 1.25, 1.5 , 1.75, 2.  ])
0+(2÷8)×↕9
#⟨ 0 0.25 0.5 0.75 1 1.25 1.5 1.75 2 ⟩
Linspace ← {(⊑𝕩+((1⊑𝕩)÷(𝕨-1))×↕𝕨}  # probably not good BQN
9 Linspace 0‿2
#⟨ 0 0.25 0.5 0.75 1 1.25 1.5 1.75 2 ⟩
#>>> x = np.linspace(0, 2 * pi, 100)        # useful to evaluate function at lots of points
#>>> f = np.sin(x)
0+(2×π÷99)×↕100
0+ (2×π)× ↕⊸÷⟜(-⟜1) 100
100 Linspace 0‿2×π
Linspace ← {(⊑𝕩)+ (1⊑𝕩)× ↕⊸÷⟜(-⟜1) 𝕨}  # another version, would like pure tacit version TODO

## Printing Arrays
#>>> a = np.arange(6)                    # 1d array
#>>> print(a)
#[0 1 2 3 4 5]
a ← ↕6
#⟨ 0 1 2 3 4 5 ⟩
a
#⟨ 0 1 2 3 4 5 ⟩
#>>>
#>>> b = np.arange(12).reshape(4, 3)     # 2d array
#>>> print(b)
#[[ 0  1  2]
# [ 3  4  5]
# [ 6  7  8]
# [ 9 10 11]]
b ← 4‿3 ⥊ ↕12
#┌─
#╵ 0  1  2
#  3  4  5
#  6  7  8
#  9 10 11
#          ┘
#>>>
#>>> c = np.arange(24).reshape(2, 3, 4)  # 3d array
#>>> print(c)
#[[[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]]
#
# [[12 13 14 15]
#  [16 17 18 19]
#  [20 21 22 23]]]
c ← 2‿3‿4 ⥊ ↕24
#┌─
#╎  0  1  2  3
#   4  5  6  7
#   8  9 10 11
#
#  12 13 14 15
#  16 17 18 19
#  20 21 22 23
#              ┘

#>>> print(np.arange(10000))
#[   0    1    2 ... 9997 9998 9999]
#>>>
#>>> print(np.arange(10000).reshape(100, 100))
#[[   0    1    2 ...   97   98   99]
# [ 100  101  102 ...  197  198  199]
# [ 200  201  202 ...  297  298  299]
# ...
# [9700 9701 9702 ... 9797 9798 9799]
# [9800 9801 9802 ... 9897 9898 9899]
# [9900 9901 9902 ... 9997 9998 9999]]
# BQN no abreviated output?

#>>> np.set_printoptions(threshold=sys.maxsize)  # sys module should be imported

## Basic Operations

#>>> a = np.array([20, 30, 40, 50])
a ← 20‿30‿40‿50
#⟨ 20 30 40 50 ⟩
#>>> b = np.arange(4)
#>>> b
#array([0, 1, 2, 3])
b ← ↕4
#⟨ 0 1 2 3 ⟩
#>>> c = a - b
#>>> c
#array([20, 29, 38, 47])
c ← a - b
⟨ 20 29 38 47 ⟩
#>>> b**2
#array([0, 1, 4, 9])
b ⋆ 2
#⟨ 0 1 4 9 ⟩

#>>> 10 * np.sin(a)
#array([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])

#sin ← {
#    half ←  5.00000000000000000000e¯01   # 0x3FE00000, 0x00000000
#    S1   ← ¯1.66666666666666324348e¯01   # 0xBFC55555, 0x55555549
#    S2   ←  8.33333333332248946124e¯03   # 0x3F811111, 0x1110F8A6
#    S3   ← ¯1.98412698298579493134e¯04   # 0xBF2A01A0, 0x19C161D5
#    S4   ←  2.75573137070700676789e¯06   # 0x3EC71DE3, 0x57B1FE7D
#    S5   ← ¯2.50507602534068634195e¯08   # 0xBE5AE5E6, 0x8A2B9CEB
#    S6   ←  1.58969099521155010221e¯10   # 0x3DE5D93A, 0x5ACFD57C
#
##ifdef __STDC__
#	double __kernel_sin(double x, double y, int iy)
##else
#	double __kernel_sin(x, y, iy)
#	double x,y; int iy;		/* iy=0 if y is zero */
##endif
#{
#	double z,r,v;
#	int ix;
#	ix = __HI(x)&0x7fffffff;	/* high word of x */
#	if(ix<0x3e400000)			/* |x| < 2**-27 */
#	   {if((int)x==0) return x;}		/* generate inexact */
#	z	=  x*x;
#	v	=  z*x;
#	r	=  S2+z*(S3+z*(S4+z*(S5+z*S6)));
#	if(iy==0) return x+v*(S1+z*r);
#	else      return x-((z*(half*y-v*r)-y)-v*S1);
#}

Sin ← { 𝕩 - ((𝕩⋆3)÷6) + ((𝕩⋆5)÷120) - ((𝕩⋆7)÷5040) }
10 × Sin¨ a
#>>> a < 35
#array([ True,  True, False, False])
