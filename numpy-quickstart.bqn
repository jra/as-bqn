# https://numpy.org/doc/stable/user/quickstart.html
# 2021-11-10

# NumPy quickstart
## Prerequisits
## The Basics

## An Example
# >>> a = np.arange(15).reshape(3, 5)
a â† âŸ¨3, 5âŸ© â¥Š â†•15
a â† 3â€¿5 â¥Š â†•15
#â”Œâ”€
#â•µ  0  1  2  3  4
#   5  6  7  8  9
#  10 11 12 13 14
#                 â”˜
# >>> a
a
#â”Œâ”€
#â•µ  0  1  2  3  4
#   5  6  7  8  9
#  10 11 12 13 14
#                 â”˜
# >>> a.shape
â‰¢a
#âŸ¨ 3 5 âŸ©
# >>> a.ndim
=a
#2
# >>> a.dtype.name
# BQN number type determined by implementation
# >>> a.itemsize
# >>> a.size
Ã—Â´â‰¢a
#15
# >>> type(a)
# >>> b = np.array([6, 7, 8])
b â† âŸ¨6, 7, 8âŸ©
b â† 6â€¿7â€¿8
# >>> b
b
#âŸ¨ 6 7 8 âŸ©
â‰¢b
#âŸ¨ 3 âŸ©
=b
#1

## Array Creation
#>>> import numpy as np
#>>> a = np.array([2, 3, 4])
a â† âŸ¨2, 3, 4âŸ©
#>>> a
#array([2, 3, 4])
a
âŸ¨2, 3, 4âŸ©
#>>> a.dtype
#dtype('int64')
#>>> b = np.array([1.2, 3.5, 5.1])
a â† âŸ¨1.2, 3.5, 5.1âŸ©
#>>> b.dtype
#dtype('float64')

#>>> b = np.array([(1.5, 2, 3), (4, 5, 6)])
b â† >âŸ¨âŸ¨1.5, 2, 3âŸ©, âŸ¨4, 5, 6âŸ©âŸ©
b â† >âŸ¨1.5â€¿2â€¿3, 4â€¿5â€¿6âŸ©
b â† 2â€¿3 â¥Š 1.5â€¿2â€¿3â€¿4â€¿5â€¿6
#â”Œâ”€
#â•µ 1.5 2 3
#    4 5 6
#          â”˜
#>>> b
#array([[1.5, 2. , 3. ],
#       [4. , 5. , 6. ]])
b
#â”Œâ”€
#â•µ 1.5 2 3
#    4 5 6
#          â”˜

#>>> c = np.array([[1, 2], [3, 4]], dtype=complex)
#>>> c
#array([[1.+0.j, 2.+0.j],
#       [3.+0.j, 4.+0.j]])
# BQN no complex type yet

#>>> np.zeros((3, 4))
#array([[0., 0., 0., 0.],
#       [0., 0., 0., 0.],
#       [0., 0., 0., 0.]])
3â€¿4 â¥Š 0
#â”Œâ”€
#â•µ 0 0 0 0
#  0 0 0 0
#  0 0 0 0
#          â”˜
#>>> np.ones((2, 3, 4), dtype=np.int16)
#array([[[1, 1, 1, 1],
#        [1, 1, 1, 1],
#        [1, 1, 1, 1]],
#
#       [[1, 1, 1, 1],
#        [1, 1, 1, 1],
#        [1, 1, 1, 1]]], dtype=int16)
2â€¿3â€¿4 â¥Š 1
#â”Œâ”€
#â• 1 1 1 1
#  1 1 1 1
#  1 1 1 1
#
#  1 1 1 1
#  1 1 1 1
#  1 1 1 1
#          â”˜
#>>> np.empty((2, 3))
#array([[3.73603959e-262, 6.02658058e-154, 6.55490914e-260],  # may vary
#       [5.30498948e-313, 3.14673309e-307, 1.00000000e+000]])
# BQN no such thing as an uninitialized array?

#>>> np.arange(10, 30, 5)
#array([10, 15, 20, 25])
10+5Ã—â†•4
#âŸ¨ 10 15 20 25 âŸ©
5 {(âŠ‘ğ•©)+ğ•¨Ã—â†•âŒˆ(-Â´âŒ½ğ•©)Ã·ğ•¨} 10â€¿30  # dzaima, BQN message board, does not work for default w value
#âŸ¨ 10 15 20 25 âŸ©
#Range â† {(âŠ‘ğ•©)+ğ•¨Ã—â†•âŒˆ(-Â´âŒ½ğ•©)Ã·ğ•¨}
#Range â† ((âŠ‘âŠ¢)+(âŠ£Ã—(â†•âˆ˜âŒˆ(-Â´(âŒ½âŠ¢)Ã·âŠ£))))
#Range â† ((âŠ‘âŠ¢)+(âŠ£Ã—(â†•âˆ˜âŒˆ(âŠ£Ã·Ëœ(-Â´âŒ½âŠ¢)))))
#Range â† ((âŠ‘âŠ¢)+(âŠ£Ã—(â†•âˆ˜âŒˆâŠ£Ã·Ëœ-Â´âˆ˜(âŒ½âŠ¢))))
Range â† {cğ•Šaâ€¿b: â†•âˆ˜âŒˆâŒ¾((a+cÃ—âŠ¢)â¼)b}  # Marshal, see chat below ...
# BQN chat >>>>
#Marshall
#It can be simplified, but I don't think you'll end up improving over the block version.
#The outermost set of parens, and one of the inside sets, can be removed, and with Â· you could get rid of two more sets.
#Marshall
#Personally I would probably use this long version because I think it describes what's being done most clearly.
#Range â† {cğ•Šaâ€¿b: â†•âˆ˜âŒˆâŒ¾((a+cÃ—âŠ¢)â¼)b}
#That is, you're going to produce a list of numbers with â†•âˆ˜âŒˆ, and then apply a+cÃ—âŠ¢ to the results. And you want it to end after b. So you undo that transformation beforehand, then reapply it after.
#dzaima
#damn, âŒ¾(Fâ¼) is pretty nice. Had a header+under version, but without the â¼, and as such it was pretty ugly
# <<<<
5 Range 10â€¿30
#âŸ¨ 10 15 20 25 âŸ©
# a + cÃ—â†•âŒŠcÃ·Ëœb - a  dutchie, BQN message board: packing params in list poor BQN, just write as needed, like
10 + 5Ã—â†•âŒŠ5Ã·Ëœ30 - 10
# cÃ—â†•âŒŠbÃ·c  if a is 0, just this
# a+cÃ—â†•l  if length is known, this (see first BQN ex for this problem)
#>>> np.arange(0, 2, 0.3)  # it accepts float arguments
#array([0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8])
(1.8Ã·6)Ã—â†•7
#âŸ¨ 0 0.3 0.6 0.8999999999999999 1.2 1.5 1.8 âŸ©
0.3 Range 0â€¿2
#âŸ¨ 0 0.3 0.6 0.8999999999999999 1.2 1.5 1.8 âŸ©

#>>> np.linspace(0, 2, 9)                   # 9 numbers from 0 to 2
#array([0.  , 0.25, 0.5 , 0.75, 1.  , 1.25, 1.5 , 1.75, 2.  ])
0+(2Ã·8)Ã—â†•9
#âŸ¨ 0 0.25 0.5 0.75 1 1.25 1.5 1.75 2 âŸ©
#Linspace â† {(âŠ‘ğ•©+((1âŠ‘ğ•©)Ã·(ğ•¨-1))Ã—â†•ğ•¨}  # probably not good BQN
#Linspace â† {(âŠ‘ğ•©)+ (1âŠ‘ğ•©)Ã— â†•âŠ¸Ã·âŸœ(-âŸœ1) ğ•¨}  # another version, would like pure tacit version TODO
Linspace â† ((âŠ‘âŠ¢)+(â†•âŠ£)Ã—(-Â´âˆ˜âŒ½âŠ¢)Ã·-âŸœ1)  # TODO rewrite like Marshall's Range above
9 Linspace 0â€¿2
#âŸ¨ 0 0.25 0.5 0.75 1 1.25 1.5 1.75 2 âŸ©
#>>> x = np.linspace(0, 2 * pi, 100)        # useful to evaluate function at lots of points
#>>> f = np.sin(x)
0+(2Ã—Ï€Ã·99)Ã—â†•100
0+ (2Ã—Ï€)Ã— â†•âŠ¸Ã·âŸœ(-âŸœ1) 100
â€¢math.Sin(â†•100)Ã—2Ã—Ï€Ã·99
x â† 100 Linspace 0â€¿2Ã—Ï€
f â† â€¢math.Sin x

## Printing Arrays
#>>> a = np.arange(6)                    # 1d array
#>>> print(a)
#[0 1 2 3 4 5]
a â† â†•6
#âŸ¨ 0 1 2 3 4 5 âŸ©
a
#âŸ¨ 0 1 2 3 4 5 âŸ©
#>>>
#>>> b = np.arange(12).reshape(4, 3)     # 2d array
#>>> print(b)
#[[ 0  1  2]
# [ 3  4  5]
# [ 6  7  8]
# [ 9 10 11]]
b â† 4â€¿3 â¥Š â†•12
#â”Œâ”€
#â•µ 0  1  2
#  3  4  5
#  6  7  8
#  9 10 11
#          â”˜
#>>>
#>>> c = np.arange(24).reshape(2, 3, 4)  # 3d array
#>>> print(c)
#[[[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]]
#
# [[12 13 14 15]
#  [16 17 18 19]
#  [20 21 22 23]]]
c â† 2â€¿3â€¿4 â¥Š â†•24
#â”Œâ”€
#â•  0  1  2  3
#   4  5  6  7
#   8  9 10 11
#
#  12 13 14 15
#  16 17 18 19
#  20 21 22 23
#              â”˜

#>>> print(np.arange(10000))
#[   0    1    2 ... 9997 9998 9999]
#>>>
#>>> print(np.arange(10000).reshape(100, 100))
#[[   0    1    2 ...   97   98   99]
# [ 100  101  102 ...  197  198  199]
# [ 200  201  202 ...  297  298  299]
# ...
# [9700 9701 9702 ... 9797 9798 9799]
# [9800 9801 9802 ... 9897 9898 9899]
# [9900 9901 9902 ... 9997 9998 9999]]
# BQN no abreviated output? format?

#>>> np.set_printoptions(threshold=sys.maxsize)  # sys module should be imported

## Basic Operations

#>>> a = np.array([20, 30, 40, 50])
a â† 20â€¿30â€¿40â€¿50
a â† 10 Range 20â€¿60
a â† 20+10Ã—â†•4
#âŸ¨ 20 30 40 50 âŸ©
#>>> b = np.arange(4)
#>>> b
#array([0, 1, 2, 3])
b â† â†•4
#âŸ¨ 0 1 2 3 âŸ©
#>>> c = a - b
#>>> c
#array([20, 29, 38, 47])
c â† a - b
âŸ¨ 20 29 38 47 âŸ©
#>>> b**2
#array([0, 1, 4, 9])
b â‹† 2
#âŸ¨ 0 1 4 9 âŸ©
#>>> 10 * np.sin(a)
#array([ 9.12945251, -9.88031624,  7.4511316 , -2.62374854])
10 Ã— â€¢math.Sin a
âŸ¨ 9.129452507276277 Â¯9.880316240928618 7.451131604793488 Â¯2.623748537039288 âŸ©
#>>> a < 35
#array([ True,  True, False, False])
a < 35
âŸ¨ 1 1 0 0 âŸ©

#>>> A = np.array([[1, 1],
#...               [0, 1]])
a â† >âŸ¨1â€¿1, 0â€¿1âŸ©
#â”Œâ”€
#â•µ 1 1
#  0 1
#      â”˜
#>>> B = np.array([[2, 0],
#...               [3, 4]])
b â† >âŸ¨2â€¿0, 3â€¿4âŸ©
#â”Œâ”€
#â•µ 2 0
#  3 4
#      â”˜
#>>> A * B     # elementwise product
#array([[2, 0],
#       [0, 4]])
a Ã— b
#â”Œâ”€
#â•µ 2 0
#  0 4
#      â”˜
#>>> A @ B     # matrix product
#array([[5, 4],
#       [3, 4]])
a +Ëâˆ˜Ã—â‰1â€¿âˆ b
#â”Œâ”€
#â•µ 5 4
#  3 4
#      â”˜
#>>> A.dot(B)  # another matrix product
#array([[5, 4],
#       [3, 4]])

#>>> rg = np.random.default_rng(1)  # create instance of default random number generator
#>>> a = np.ones((2, 3), dtype=int)
a â† 2â€¿3 â¥Š 1
#â”Œâ”€
#â•µ 1 1 1
#  1 1 1
#        â”˜
#>>> b = rg.random((2, 3))
b â† 2â€¿3 â€¢rand.Range 0
#â”Œâ”€
#â•µ 0.5681749980335864 0.5240789810062436 0.04784389467423078
#   0.494469688429384  0.293539386932129 0.08746621407139887
#                                                            â”˜
#>>> a *= 3
#>>> a
#array([[3, 3, 3],
#       [3, 3, 3]])
a Ã—â†© 3
#â”Œâ”€
#â•µ 3 3 3
#  3 3 3
#        â”˜
#>>> b += a
#>>> b
#array([[3.51182162, 3.9504637 , 3.14415961],
#       [3.94864945, 3.31183145, 3.42332645]])
b +â†© a
#â”Œâ”€
#â•µ 3.568174998033586 3.524078981006244 3.047843894674231
#  3.494469688429384 3.293539386932129 3.087466214071399
#                                                        â”˜
#>>> a += b  # b is not automatically converted to integer type
#Traceback (most recent call last):
#    ...
#numpy.core._exceptions._UFuncOutputCastingError: Cannot cast ufunc 'add' output from dtype('float64') to dtype('int64') with casting rule 'same_kind'
a +â†© b
#â”Œâ”€
#â•µ 6.568174998033586 6.524078981006244 6.047843894674231
#  6.494469688429384 6.293539386932129 6.087466214071399
#                                                        â”˜

#>>> a = np.ones(3, dtype=np.int32)
a â† 3 â¥Š 1
âŸ¨ 1 1 1 âŸ©
#>>> b = np.linspace(0, pi, 3)
b â† 3 Linspace 0â€¿Ï€
âŸ¨ 0 1.570796326794897 3.141592653589793 âŸ©
#>>> b.dtype.name
#'float64'
#>>> c = a + b
#>>> c
#array([1.        , 2.57079633, 4.14159265])
c â† a + b
âŸ¨ 1 2.570796326794897 4.141592653589793 âŸ©
#>>> c.dtype.name
#'float64'
#>>> d = np.exp(c * 1j)
#>>> d
#array([ 0.54030231+0.84147098j, -0.84147098+0.54030231j,
#       -0.54030231-0.84147098j])
d â† â‹†c  # no complex numbers yet :( in BQN
âŸ¨ 2.718281828459045 13.07623325089137 62.90292428163998 âŸ©
#>>> d.dtype.name
#'complex128'

#>>> a = rg.random((2, 3))
#>>> a
#array([[0.82770259, 0.40919914, 0.54959369],
#       [0.02755911, 0.75351311, 0.53814331]])
a â† 2â€¿3 â€¢rand.Range 0
#â”Œâ”€
#â•µ 0.01699771436482989 0.2509270985708514 0.1082675942818685
#   0.6690983736891898 0.3032168815081075 0.3458953326929901
#                                                            â”˜
#>>> a.sum()
#3.1057109529998157
+Â´â¥Ša
#1.694402995107837
#>>> a.min()
#0.027559113243068367
âŒŠÂ´â¥Ša
#0.01699771436482989
#>>> a.max()
#0.8277025938204418
âŒˆÂ´â¥Ša
#0.6690983736891898

#>>> b = np.arange(12).reshape(3, 4)
b â† 3â€¿4 â¥Š â†•12
#>>> b
#array([[ 0,  1,  2,  3],
#       [ 4,  5,  6,  7],
#       [ 8,  9, 10, 11]])
#>>>
#>>> b.sum(axis=0)     # sum of each column
#array([12, 15, 18, 21])
+Ë˜b
#âŸ¨ 12 15 18 21 âŸ©
+Ëâ‰2 b
#âŸ¨ 12 15 18 21 âŸ©
#>>>
#>>> b.min(axis=1)     # min of each row
#array([0, 4, 8])
âŒŠËâ‰b  # probably a better way, TODO
âŸ¨ 0 4 8 âŸ©
âŒŠËâ‰1 b  # from BQNcrate
âŸ¨ 0 4 8 âŸ©
#>>>
#>>> b.cumsum(axis=1)  # cumulative sum along each row
#array([[ 0,  1,  3,  6],
#       [ 4,  9, 15, 22],
#       [ 8, 17, 27, 38]])
+`Ë˜ b
#â”Œâ”€
#â•µ 0  1  3  6
#  4  9 15 22
#  8 17 27 38
#             â”˜
+`â‰1 b
#â”Œâ”€
#â•µ 0  1  3  6
#  4  9 15 22
#  8 17 27 38
#             â”˜

# https://aplwiki.com/wiki/Rank_%28operator%29
# https://mlochbaum.github.io/BQN/doc/leading.html
# rank docs in the JforC book to be very helpful in understanding rank and leading axis concepts.
#+Ëâ‰2 means to apply +Ë on cells of rank 2. With a rank-2 argument, the entire array is a cell, so it's the same as applying +Ë without any Rank modifier.
#With âŒŠËâ‰1, you're applying to 1-cells, which are rows. So "minimum of each row" is basically a direct translation.
# https://www.jsoftware.com/help/jforc/loopless_code_i_verbs_have_r.htm#_Toc191734333
# https://www.jsoftware.com/docs/help807/jforc/contents.htm
#   cells rank
#One thing to watch out for if you're coming from Numpy is that numpy shapes are "trailing axis matching" whereas most array languages have "leading axis matching". IMO that's numpy's biggest design mistake.
#This shows up in situations like where you have 1 2 3 and 10 11 12 13 and you'd like to add them, resulting in a 3x4 matrix like this:
#11 12 13 14
#12 13 14 15
#13 14 15 16
#In numpy, you end up adding an axis to one or the other of the data. In array languages, you apply the function to a subset of the data (BQN uses "depth" for this I think).
#That's one of the best features of array langs, in my opinion. Modify the function to fit the data, rather than modify the data to fit weird broadcasting rules.


## Universal Functions

#>>> B = np.arange(3)
#>>> B
#array([0, 1, 2])
b â† â†•3
#âŸ¨ 0 1 2 âŸ©
#>>> np.exp(B)
#array([1.        , 2.71828183, 7.3890561 ])
â‹†b
#âŸ¨ 1 2.718281828459045 7.38905609893065 âŸ©
#>>> np.sqrt(B)
#array([0.        , 1.        , 1.41421356])
âˆšb
#âŸ¨ 0 1 1.414213562373095 âŸ©
#>>> C = np.array([2., -1., 4.])
c â† 2â€¿Â¯1â€¿4
âŸ¨ 2 Â¯1 4 âŸ©
#>>> np.add(B, C)
#array([2., 0., 6.])
b + c
âŸ¨ 2 0 6 âŸ©

## Index, Slicing, and Iterating

#>>> a = np.arange(10)**3
#>>> a
#array([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])
a â† (â†•10)â‹†3
a â† 3â‹†Ëœâ†•10
#âŸ¨ 0 1 8 27 64 125 216 343 512 729 âŸ©
#>>> a[2]
#8
2âŠ‘a
#8
#>>> a[2:5]
#array([ 8, 27, 64])
3â†‘2â†“a  # TODO, not quite. want to slice with original indicies
(2+â†•3)âŠa  # better, still not quite, using first index + length
(2+â†•5-2)âŠa  # now in terms of indicies, but not great
Slice â† (1 Range âŠ£)âŠâŠ¢  # might be ok, need Range with w default to 1
2â€¿5 Slice a
(â†•âŒ¾(-âŸœ2)5) âŠ a  # thish should be pretty close to ok/good BQN
#âŸ¨ 8 27 64 âŸ©
#>>> # equivalent to a[0:6:2] = 1000;
#>>> # from start to position 6, exclusive, set every 2nd element to 1000
#>>> a[:6:2] = 1000
#>>> a
#array([1000,    1, 1000,   27, 1000,  125,  216,  343,  512,  729])
# TODO study / understand this
#aâ†3â‹†Ëœâ†•10 â‹„ a 1000Â¨âŒ¾((2Ã—â†•3)âŠ¸âŠ)
1000Â¨âŒ¾((2Ã—â†•3)âŠ¸âŠ) a
a 1000Â¨âŒ¾((2Ã—â†•3)âŠ¸âŠ)â†©  # not perfect, probably want in terms of 2 and 6, but ok
âŸ¨ 1000 1 1000 27 1000 125 216 343 512 729 âŸ©

#>>> a[::-1]  # reversed a
#array([ 729,  512,  343,  216,  125, 1000,   27, 1000,    1, 1000])
âŒ½a
#>>> for i in a:
#...     print(i**(1 / 3.))
#...
#9.999999999999998
#1.0
#9.999999999999998
#3.0
#9.999999999999998
#4.999999999999999
#5.999999999999999
#6.999999999999999
#7.999999999999999
#8.999999999999998
(â€¢Show 3âŠ¸âˆš)Â¨ a
#9.999999999999998
#1
#9.999999999999998
#3
#9.999999999999998
#4.999999999999999
#5.999999999999999
#6.999999999999999
#7.999999999999999
#8.999999999999998
#âŸ¨ 9.999999999999998 1 9.999999999999998 3 9.999999999999998 4.999999999999999 5.999999999999999 6.999999999999999 7.999999999999999 8.999999999999998 âŸ©

#>>> def f(x, y):
#...     return 10 * x + y
#...
F â† (âŠ¢+10Ã—âŠ£)
#>>> b = np.fromfunction(f, (5, 4), dtype=int)
#>>> b
#array([[ 0,  1,  2,  3],
#       [10, 11, 12, 13],
#       [20, 21, 22, 23],
#       [30, 31, 32, 33],
#       [40, 41, 42, 43]])
b â† (â†•5)FâŒœâ†•4
#â”Œâ”€
#â•µ  0  1  2  3
#  10 11 12 13
#  20 21 22 23
#  30 31 32 33
#  40 41 42 43
#              â”˜
#>>> b[2, 3]
#23
2â€¿3 âŠ‘ b
#23
#>>> b[0:5, 1]  # each row in the second column of b
#array([ 1, 11, 21, 31, 41])
((â†•5)â‰Â¨5â¥Š1) âŠ‘ b  # explicit rows, all rows below
#âŸ¨ 1 11 21 31 41 âŸ©
#>>> b[:, 1]    # equivalent to the previous example
#array([ 1, 11, 21, 31, 41])
1âŠ‘Ë˜b
#âŸ¨ 1 11 21 31 41 âŸ©
#>>> b[1:3, :]  # each column in the second and third row of b
#array([[10, 11, 12, 13],
#       [20, 21, 22, 23]])
1â€¿2âŠb
#â”Œâ”€
#â•µ 10 11 12 13
#  20 21 22 23
#              â”˜

#>>> b[-1]   # the last row. Equivalent to b[-1, :]
#array([40, 41, 42, 43])
Â¯1âŠb
#âŸ¨ 40 41 42 43 âŸ©

#>>> c = np.array([[[  0,  1,  2],  # a 3D array (two stacked 2D arrays)
#...                [ 10, 12, 13]],
#...               [[100, 101, 102],
#...                [110, 112, 113]]])
c â† >>âŸ¨âŸ¨0â€¿1â€¿2, 10â€¿12â€¿13âŸ©, âŸ¨100â€¿101â€¿102, 110â€¿112â€¿113âŸ©âŸ©
#â”Œâ”€
#â•   0   1   2
#   10  12  13
#
#  100 101 102
#  110 112 113
#              â”˜
# TODO construct c more cleverly
#>>> c.shape
#(2, 2, 3)
â‰¢c
#âŸ¨ 2 2 3 âŸ©
#>>> c[1, ...]  # same as c[1, :, :] or c[1]
#array([[100, 101, 102],
#       [110, 112, 113]])
1âŠc
1âŠâ‰3 c  # more explicit
#â”Œâ”€
#â•µ 100 101 102
#  110 112 113
#              â”˜
#>>> c[..., 2]  # same as c[:, :, 2]
#array([[  2,  13],
#       [102, 113]])
2âŠâ‰1 c
#â”Œâ”€
#â•µ   2  13
#  102 113
#          â”˜

#>>> for row in b:
#...     print(row)
#...
#[0 1 2 3]
#[10 11 12 13]
#[20 21 22 23]
#[30 31 32 33]
#[40 41 42 43]
â€¢ShowË˜ b
#âŸ¨ 0 1 2 3 âŸ©
#âŸ¨ 10 11 12 13 âŸ©
#âŸ¨ 20 21 22 23 âŸ©
#âŸ¨ 30 31 32 33 âŸ©
#âŸ¨ 40 41 42 43 âŸ©
#â”Œâ”€
#â•µ  0  1  2  3
#  10 11 12 13
#  20 21 22 23
#  30 31 32 33
#  40 41 42 43
#              â”˜

#>>> for element in b.flat:
#...     print(element)
#...
#0
#1
#2
#3
#10
#11
#12
#13
#20
#21
#22
#23
#30
#31
#32
#33
#40
#41
#42
#43
â€¢ShowÂ¨ b
#0
#1
#2
#3
#10
#11
#12
#13
#20
#21
#22
#23
#30
#31
#32
#33
#40
#41
#42
#43
#â”Œâ”€
#â•µ  0  1  2  3
#  10 11 12 13
#  20 21 22 23
#  30 31 32 33
#  40 41 42 43
#              â”˜


#>>> a = np.floor(10 * rg.random((3, 4)))
#>>> a
#array([[3., 7., 3., 4.],
#       [1., 4., 2., 2.],
#       [7., 2., 4., 9.]])
#>>> a.shape
#(3, 4)

   a â† âŒŠ10Ã—3â€¿4 â€¢rand.Range 0
â”Œâ”€
â•µ 4 0 6 8
  6 3 2 0
  5 3 9 8
          â”˜
   â‰¢a
âŸ¨ 3 4 âŸ©


#>>> a.ravel()  # returns the array, flattened
#array([3., 7., 3., 4., 1., 4., 2., 2., 7., 2., 4., 9.])
#>>> a.reshape(6, 2)  # returns the array with a modified shape
#array([[3., 7.],
#       [3., 4.],
#       [1., 4.],
#       [2., 2.],
#       [7., 2.],
#       [4., 9.]])
#>>> a.T  # returns the array, transposed
#array([[3., 1., 7.],
#       [7., 4., 2.],
#       [3., 2., 4.],
#       [4., 2., 9.]])
#>>> a.T.shape
#(4, 3)
#>>> a.shape
#(3, 4)

   â¥Ša
âŸ¨ 4 0 6 8 6 3 2 0 5 3 9 8 âŸ©
   6â€¿2â¥Ša
â”Œâ”€
â•µ 4 0
  6 8
  6 3
  2 0
  5 3
  9 8
      â”˜
   â‰a
â”Œâ”€
â•µ 4 6 5
  0 3 3
  6 2 9
  8 0 8
        â”˜
   â‰¢â‰a
âŸ¨ 4 3 âŸ©
   â‰¢a
âŸ¨ 3 4 âŸ©

#>>> a
#array([[3., 7., 3., 4.],
#       [1., 4., 2., 2.],
#       [7., 2., 4., 9.]])
#>>> a.resize((2, 6))
#>>> a
#array([[3., 7., 3., 4., 1., 4.],
#       [2., 2., 7., 2., 4., 9.]])

   a â† âŒŠ10Ã—3â€¿4 â€¢rand.Range 0
â”Œâ”€
â•µ 2 1 2 9
  1 5 5 5
  1 8 1 5
          â”˜
   a (â¥ŠËœ)â†© 2â€¿6
â”Œâ”€
â•µ 2 1 2 9 1 5
  5 5 1 8 1 5
              â”˜
   a
â”Œâ”€
â•µ 2 1 2 9 1 5
  5 5 1 8 1 5
              â”˜

# Shape Manipulation

## Changing the shap of an array

#>>> a.reshape(3, -1)
#array([[3., 7., 3., 4.],
#       [1., 4., 2., 2.],
#       [7., 2., 4., 9.]])
   3â€¿4 â¥Š a  # I don't think BQN will auto-calc missing dims????
â”Œâ”€
â•µ 2 1 2 9
  1 5 5 5
  1 8 1 5
          â”˜
## Stacking together different arrays

#>>> a = np.floor(10 * rg.random((2, 2)))
#>>> a
#array([[9., 7.],
#       [5., 2.]])
#>>> b = np.floor(10 * rg.random((2, 2)))
#>>> b
#array([[1., 9.],
#       [5., 1.]])
#>>> np.vstack((a, b))
#array([[9., 7.],
#       [5., 2.],
#       [1., 9.],
#       [5., 1.]])
#>>> np.hstack((a, b))
#array([[9., 7., 1., 9.],
#       [5., 2., 5., 1.]])

a â† âŒŠ10Ã— 2â€¿2 â€¢rand.Range 0
â”Œâ”€
â•µ 2 5
  6 7
      â”˜
   b â† âŒŠ10Ã— 2â€¿2 â€¢rand.Range 0
â”Œâ”€
â•µ 1 2
  0 4
      â”˜
   a âˆ¾ b
â”Œâ”€
â•µ 2 5
  6 7
  1 2
  0 4
      â”˜
   a âˆ¾Ë˜ b
â”Œâ”€
â•µ 2 5 1 2
  6 7 0 4
          â”˜


#>>> from numpy import newaxis
#>>> np.column_stack((a, b))  # with 2D arrays
#array([[9., 7., 1., 9.],
#       [5., 2., 5., 1.]])
#>>> a = np.array([4., 2.])
#>>> b = np.array([3., 8.])
#>>> np.column_stack((a, b))  # returns a 2D array
#array([[4., 3.],
#       [2., 8.]])
#>>> np.hstack((a, b))        # the result is different
#array([4., 2., 3., 8.])
#>>> a[:, newaxis]  # view `a` as a 2D column vector
#array([[4.],
#       [2.]])
#>>> np.column_stack((a[:, newaxis], b[:, newaxis]))
#array([[4., 3.],
#       [2., 8.]])
#>>> np.hstack((a[:, newaxis], b[:, newaxis]))  # the result is the same
#array([[4., 3.],
#       [2., 8.]])

   a âˆ¾Ë˜ b
â”Œâ”€
â•µ 2 5 1 2
  6 7 0 4
          â”˜
   a â† 4â€¿2
âŸ¨ 4 2 âŸ©
   b â† 3â€¿8
âŸ¨ 3 8 âŸ©
   â‰>aâ€¿b
â”Œâ”€
â•µ 4 3
  2 8
      â”˜
   aâˆ¾b
âŸ¨ 4 2 3 8 âŸ©
   â‰>âŸ¨aâŸ©
â”Œâ”€
â•µ 4
  2
    â”˜
   (â‰>âŸ¨aâŸ©) âˆ¾Ë˜ â‰>âŸ¨bâŸ©
â”Œâ”€
â•µ 4 3
  2 8
      â”˜

# Splitting one array into several smaller ones

#>>> a = np.floor(10 * rg.random((2, 12)))
#>>> a
#array([[6., 7., 6., 9., 0., 5., 4., 0., 6., 8., 5., 2.],
#       [8., 5., 5., 7., 1., 8., 6., 7., 1., 8., 1., 0.]])
#>>> # Split `a` into 3
#>>> np.hsplit(a, 3)
#[array([[6., 7., 6., 9.],
#       [8., 5., 5., 7.]]), array([[0., 5., 4., 0.],
#       [1., 8., 6., 7.]]), array([[6., 8., 5., 2.],
#       [1., 8., 1., 0.]])]
#>>> # Split `a` after the third and the fourth column
#>>> np.hsplit(a, (3, 4))
#[array([[6., 7., 6.],
#       [8., 5., 5.]]), array([[9.],
#       [7.]]), array([[0., 5., 4., 0., 6., 8., 5., 2.],
#       [1., 8., 6., 7., 1., 8., 1., 0.]])]

   a â† âŒŠ10Ã—2â€¿12 â€¢rand.Range 0
â”Œâ”€
â•µ 4 1 1 9 5 1 2 3 3 1 1 0
  2 9 8 1 9 4 3 4 1 8 1 1
                          â”˜
   a
â”Œâ”€
â•µ 4 1 1 9 5 1 2 3 3 1 1 0
  2 9 8 1 9 4 3 4 1 8 1 1
                          â”˜
   âŠâŸ¨âŸ¨2âŸ©,3â¥Š4âŸ© /Â¨âŠ¸âŠ” a  # explicit, knowing/using a dims
â”Œâ”€
Â· â”Œâ”€          â”Œâ”€          â”Œâ”€
  â•µ 4 1 1 9   â•µ 5 1 2 3   â•µ 3 1 1 0
    2 9 8 1     9 4 3 4     1 8 1 1
            â”˜           â”˜           â”˜
                                      â”˜
#   âŠâŸ¨âŸ¨âŠ‘â‰¢aâŸ©,3â¥ŠâŒˆ(1âŠ‘â‰¢a)Ã·3âŸ© /Â¨âŠ¸âŠ” a  # in terms of number of partitions, create fn with this?
#â”Œâ”€
#Â· â”Œâ”€          â”Œâ”€          â”Œâ”€
#  â•µ 4 1 1 9   â•µ 5 1 2 3   â•µ 3 1 1 0
#    2 9 8 1     9 4 3 4     1 8 1 1
#            â”˜           â”˜           â”˜
#                                      â”˜
#   â‰Â¨(/3â¥Š4) âŠ” â‰a  # my initial attempt
#â”Œâ”€
#Â· â”Œâ”€          â”Œâ”€          â”Œâ”€
#  â•µ 4 1 1 9   â•µ 5 1 2 3   â•µ 3 1 1 0
#    2 9 8 1     9 4 3 4     1 8 1 1
#            â”˜           â”˜           â”˜
#                                      â”˜
## Marshal's responses on how to partition
#âŸ¨2â€¿3,1â€¿2â€¿0â€¿1âŸ© /Â¨âŠ¸âŠ” 'a'+â¥ŠâŸœ(â†•Ã—Â´)5â€¿4
#(/1â€¿2â€¿0â€¿1)âŠ¸âŠ”Ë˜ 'a'+â¥ŠâŸœ(â†•Ã—Â´)2â€¿4
## That's Cells (Ë˜) to partition only the second axis.
#âŸ¨2â¥Š0, (3â¥Š4)/â†•3âŸ© âŠ” 2â€¿12â¥Š"abcde"
## But note that the result has rank 2 rather than being a list, so you should probably apply â‰â¼ or âŠ to it.
   âŠâŸ¨âŸ¨2âŸ©,3â€¿1â€¿8âŸ© /Â¨âŠ¸âŠ” a
â”Œâ”€
Â· â”Œâ”€        â”Œâ”€    â”Œâ”€
  â•µ 4 1 1   â•µ 9   â•µ 5 1 2 3 3 1 1 0
    2 9 8     1     9 4 3 4 1 8 1 1
          â”˜     â”˜                   â”˜
                                      â”˜


# Copies and Views

## No Copy at All

#>>> a = np.array([[ 0,  1,  2,  3],
#...               [ 4,  5,  6,  7],
#...               [ 8,  9, 10, 11]])
#>>> b = a            # no new object is created
#>>> b is a           # a and b are two names for the same ndarray object
#True

   a â† 3â€¿4â¥Šâ†•12
â”Œâ”€
â•µ 0 1  2  3
  4 5  6  7
  8 9 10 11
            â”˜
   b â† a
â”Œâ”€
â•µ 0 1  2  3
  4 5  6  7
  8 9 10 11
            â”˜
   a 1000âŒ¾(1â€¿2âŠ¸âŠ‘)â†©  # is this the right way to change an element
â”Œâ”€
â•µ 0 1    2  3
  4 5 1000  7
  8 9   10 11
              â”˜
   a
â”Œâ”€
â•µ 0 1    2  3
  4 5 1000  7
  8 9   10 11
              â”˜
   b  # arrays are immutable
â”Œâ”€
â•µ 0 1  2  3
  4 5  6  7
  8 9 10 11
            â”˜


#>>> def f(x):
#...     print(id(x))
#...
#>>> id(a)  # id is a unique identifier of an object
#148293216  # may vary
#>>> f(a)
#148293216  # may vary

   F â† {ğ•© 999âŒ¾(1â€¿2âŠ¸âŠ‘)â†©}
(function block)
   F a
â”Œâ”€
â•µ 0 1   2  3
  4 5 999  7
  8 9  10 11
             â”˜
   a  # looks like not pass by ref
â”Œâ”€
â•µ 0 1    2  3
  4 5 1000  7
  8 9   10 11
              â”˜

## View or Shallow Copy

#>>> c = a.view()
#>>> c is a
#False
#>>> c.base is a            # c is a view of the data owned by a
#True
#>>> c.flags.owndata
#False
#>>>
#>>> c = c.reshape((2, 6))  # a's shape doesn't change
#>>> a.shape
#(3, 4)
#>>> c[0, 4] = 1234         # a's data changes
#>>> a
#array([[   0,    1,    2,    3],
#       [1234,    5,    6,    7],
#       [   8,    9,   10,   11]])

   c â† a
â”Œâ”€
â•µ 0 1    2  3
  4 5 1000  7
  8 9   10 11
              â”˜
   c 2â€¿6âŠ¸â¥Šâ†©
â”Œâ”€
â•µ    0 1 2 3  4  5
  1000 7 8 9 10 11
                   â”˜
   â‰¢a
âŸ¨ 3 4 âŸ©
   c 1234âŒ¾(0â€¿4âŠ¸âŠ‘)â†©
â”Œâ”€
â•µ    0 1 2 3 1234  5
  1000 7 8 9   10 11
                     â”˜
   a  # c is not a view of a, it is its own copy
â”Œâ”€
â•µ 0 1    2  3
  4 5 1000  7
  8 9   10 11
              â”˜

#>>> s = a[:, 1:3]
#>>> s[:] = 10  # s[:] is a view of s. Note the difference between s = 10 and s[:] = 10
#>>> a
#array([[   0,   10,   10,    3],
#       [1234,   10,   10,    7],
#       [   8,   10,   10,   11]])

   s â† 1â€¿2âŠâ‰1 a
â”Œâ”€
â•µ 1    2
  5 1000
  9   10
         â”˜
   s 10Â¨âŒ¾(âŸ¨â†•3,â†•2âŸ©âŠ¸âŠ)â†©  # s gets a new array
â”Œâ”€
â•µ 10 10
  10 10
  10 10
        â”˜
   s
â”Œâ”€
â•µ 10 10
  10 10
  10 10
        â”˜
   a  # s is not a view of a, they are distinct
â”Œâ”€
â•µ 0 1    2  3
  4 5 1000  7
  8 9   10 11
              â”˜

## Deep Copy

#>>> d = a.copy()  # a new array object with new data is created
#>>> d is a
#False
#>>> d.base is a  # d doesn't share anything with a
#False
#>>> d[0, 0] = 9999
#>>> a
#array([[   0,   10,   10,    3],
#       [1234,   10,   10,    7],
#       [   8,   10,   10,   11]])


#>>> a = np.arange(int(1e8))
#>>> b = a[:100].copy()
#>>> del a  # the memory of ``a`` can be released.


## Functions and Methods Overview

# Less Basic
## Broadcasting Rules

# Advanced indexing and index tricks
## Indexing with Arrays of Indicies
## Indexing with Boolean Arrays
## The ix_() function
## Indexing with strings

# Tricks and Tips
## "Automatic" Reshaping
## Vector Stacking
## Histograms

# Further reading
## The Python tutorial
## Command Reference
## SciPy Tutorial
## SciPy Lecture Notes
## A matlab, R, IDL, NumPy/SciPy dictionary
## Tutorial: Linear algebra on n-dimensional arrays
